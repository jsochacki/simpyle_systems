"""
Author: socHACKi
This module is a collection of classes that can be used to help
the user make system level synthesizer design choices and analysis.
There are also some matlab like functions that are implemented.
"""

import numpy as np
import os
import pandas as pd
import matplotlib.pyplot as plt

plt.ioff()

#from socHACKi.socHACKiUtilityPackage import AttrDict

class IntegerBoundarySpurs(object):
    r"""
    This is a class that takes the path to a file that is generated by
    ADISimFrequencyPlanner and some additional frequency information and
    analyzes the spur values at the frequencies of use for different
    reference frequencies and analyzes the additive noise per
    tuning step size and reference frequency.

    File names for analysis must end in .csv, and have the reference frequency
    in the title in MHz and the use case (Rx or Tx) or else this class
    will ignore them.

    Results can be viewed and/or saved to excel files and pngs/pdfs

    Parameters
    ----------

        File Path : String
                     Absolute path to folder containing .csv files
                     from ADISimFrequencyPlanner

        Reference Frequencies : List, Int
                     This is a list of the reference
                     frequencies that correspond to the
                     data in the files and the file
                     names

        Cumulative LO Multiplication : float
                     This is the difference in the synthesizer design frequency
                     and the end system use frequency so that the spur level
                     and additive noise are propely calculated

        LO Tuning Range : float
                     This is the desired tuning range in MHz of the
                     final design at the end system use frequency

        LO Frequency Dictionary : Dictionary {string:list_float}
                     This is a dictionary that specifies the synthesizer
                     center frequencies to be used for the additive noise
                     analysis for the Tx and Rx files.

        Lowest Frequencies Synthesized : Dictionary {string:float}
                     This is a dictionary that specifies the lowest frequency
                     used in the Tx files and Rx files analyzed.  This is
                     to overcome an issue built into ADISimFrequencyPlanner.
                     The ADI software cuts the LO output frequency in half
                     at some data point aside of what you have asked it to do
                     All frequency values below the set values will be doubled
                     to correct for this.  Their corresponding values will
                     not as they are correct in their current state.

        Cumulative Additive Noise Limit : float, optional
                     This is the Cumulative Additive Noise Limit for use in
                     plotting

    Returns
    -------

        object : IntegerBoundarySpurs object
                 This object is what you can interact with to get the results
                 out of the analysis that it does.

    See Also
    --------

    Nothing currently

    Example
    -------

    >>> file_path = r'C:\Users\Desktop\temp'
    >>> reference_frequencies = [100, 200, 300]
    >>> cumulative_LO_mutiplication = 2
    >>> lo_tuning_range = 125
    >>> lo_frequency_dict = {'Rx': [5800,
    >>>                             6000,
    >>>                             6500],
    >>>                      'Tx': [10000,
    >>>                             10200,
    >>>                             10400]}
    >>> adjustment_dict = {'Rx': 5800,
    >>>                    'Tx': 5800}
    >>> cumulative_additive_noise_limit = 0.3
    >>> instance = IntegerBoundarySpurs(
    >>>                file_path,
    >>>                reference_frequencies,
    >>>                cumulative_LO_mutiplication,
    >>>                lo_tuning_range,
    >>>                lo_frequency_dict,
    >>>                adjustment_dict,
    >>>                cumulative_additive_noise_limit)
    <simpyle_systems.synthesizer.IntegerBoundarySpurs at 0xab73a58>


    """

    def __init__(self, *args):

        self._post_fix = '.csv'

        # Intake Processing
        if 7 >= len(args) >= 6:
            self._file_path = args[0]
            self._reference_frequencies = args[1]
            self._cumulative_LO_mutiplication = args[2]
            self._lo_tuning_range = args[3]
            self._lo_frequency_dict = args[4]
            self._adjustment_dict = args[5]
            if len(args) == 7:
                self._cumulative_additive_noise_limit = args[6]
            else:
                self._cumulative_additive_noise_limit = 0
        else:
            raise TypeError('IntegerBoundarySpurs requres between 6 and 7 '
                            'arguements but instead received '
                            '{0}'.format(len(args)))

        # Need to scale LOs for analysis at output frequencies
        for Key in self._lo_frequency_dict:
            temp = [Element * self._cumulative_LO_mutiplication
                    for Element in self._lo_frequency_dict[Key]]
            self._lo_frequency_dict.update({Key: temp})

        # General Initialization
        self._lo_tuning_step_sizes = np.arange(1,
                                             self._lo_tuning_range /
                                             self._cumulative_LO_mutiplication,
                                               1)
        self._result_type_list = ['f_vals_MHz',
                                  'dominant_IBS_spur_per_frequency',
                                  'cumulative_additive_noise_per_frequency',
                                  'effective_tuning_step_size_MHz',
                                  'maximum_cumulative_additive_noise_per_step',
                                  'range_tuned',
                                  'center_frequency_hit',
                                  'worst_case_maximum_cumulative_additive_noise_per_step']

        self._effective_tuning_step_size = self._lo_tuning_step_sizes * \
                                           self._cumulative_LO_mutiplication
        self._set_dict = {'Rx': self.reference_frequencies,
                          'Tx': self.reference_frequencies}
        self._results_dictionary = {}

        self._results_directory_name = None

        # Autorun key methods
        self.read_files_and_adjust()
        self.process_files()
        self.create_results_folder()

#        self.write_results_to_excel()
#        self.spurious_plots_vs_synthesizer_output()
#        self.additive_noise_plots_vs_tuning_step_size()
#        self.additive_noise_plots_vs_synthesizer_output()
#        self.worst_case_additive_noise_plots_vs_tuning_step_size()
#        close_all_figs

    @property
    def post_fix(self):
        return self._post_fix

    @property
    def file_path(self):
        return self._file_path

    @property
    def reference_frequencies(self):
        return self._reference_frequencies

    @property
    def cumulative_LO_mutiplication(self):
        return self._cumulative_LO_mutiplication

    @property
    def lo_tuning_range(self):
        return self._lo_tuning_range

    @property
    def lo_frequency_dict(self):
        return self._lo_frequency_dict

    @property
    def adjustment_dict(self):
        return self._adjustment_dict

    @property
    def cumulative_additive_noise_limit(self):
        return self._cumulative_additive_noise_limit

    @property
    def lo_tuning_step_sizes(self):
        return self._lo_tuning_step_sizes

    @property
    def result_type_list(self):
        return self._result_type_list

    @property
    def effective_tuning_step_size(self):
        return self._effective_tuning_step_size

    @property
    def set_dict(self):
        return self._set_dict

    @property
    def results_dictionary(self):
        return self._results_dictionary

    @results_dictionary.setter
    def results_dictionary():
        pass

    @property
    def results_directory_name(self):
        return self._results_directory_name

    def process_files(self):
        self.nominal_analysis()
        self.worst_case_analysis()

    def read_files_and_adjust(self):

        available_files = os.listdir(self.file_path)

        for Key in self.set_dict:
            reference_frequencies = self.set_dict[Key]
            self._results_dictionary.update({Key:{}})
            for ReferenceFrequency in reference_frequencies:
                for File in available_files:
                    if (Key in File) \
                       and (str(ReferenceFrequency) in File) \
                       and (self.post_fix in File):
                        self._results_dictionary[Key].update({ReferenceFrequency:{}})

                        data_array = np.loadtxt(os.path.join(self.file_path,File),
                                                dtype=np.float32, delimiter=',',
                                                usecols=(1, 23, 25, 27, 28, 29),
                                                skiprows=8,
                                                unpack=True)

                        analysis_synthesizer_frequency_values = data_array[0,:]

                        IBS_1_values = np.array(data_array[1,:])
                        IBS_2_values = np.array(data_array[2,:])
                        IBS_3_values = np.array(data_array[3,:])
                        IBS_4_values = np.array(data_array[4,:])
                        IBS_5_values = np.array(data_array[5,:])

                        analysis_synthesizer_frequency_values = np.array(
                            [Frequency
                                 if (Frequency >= self.adjustment_dict[Key])
                                 else Frequency*2
                                 for Frequency in analysis_synthesizer_frequency_values])

                        synthesizer_frequency_values = \
                            analysis_synthesizer_frequency_values * \
                            self.cumulative_LO_mutiplication

                        IBS_1_values = \
                            IBS_1_values + 20*np.log10(self.cumulative_LO_mutiplication)
                        IBS_2_values = \
                            IBS_2_values + 20*np.log10(self.cumulative_LO_mutiplication)
                        IBS_3_values = \
                            IBS_3_values + 20*np.log10(self.cumulative_LO_mutiplication)
                        IBS_4_values = \
                            IBS_4_values + 20*np.log10(self.cumulative_LO_mutiplication)
                        IBS_5_values = \
                            IBS_5_values + 20*np.log10(self.cumulative_LO_mutiplication)

                        spurs_at_frequencies = np.array(
                                [[IBS_1_values[Index],
                                  IBS_2_values[Index],
                                  IBS_3_values[Index],
                                  IBS_4_values[Index],
                                  IBS_5_values[Index]]
                                    for Index, Value in enumerate(IBS_1_values)]
                                                       )
                        dominant_ibs_spur = np.array(
                                [np.max(spurs_at_frequencies[Index])
                                    for Index, Value in enumerate(spurs_at_frequencies)]
                                                    )
                        cumulative_additive_noise = \
                            np.sqrt(2 * np.sum(np.power(10,
                                                        spurs_at_frequencies/10),
                                               axis=1)
                                    ) / ((2 * np.pi) / 360)
                        self._results_dictionary[Key][ReferenceFrequency].update(
                                {self.result_type_list[0]: synthesizer_frequency_values,
                                 self.result_type_list[1]: dominant_ibs_spur,
                                 self.result_type_list[2]: cumulative_additive_noise
                                 })

    def nominal_analysis(self):
        for Key in self.set_dict:
            reference_frequencies = self.set_dict[Key]
            for ReferenceFrequency in reference_frequencies:
                for LoCenterFrequency in self.lo_frequency_dict[Key]:
                    self._results_dictionary[
                            Key][
                            ReferenceFrequency].update({LoCenterFrequency:{}})
                    max_additive_noise_array = []
                    current_tuning_range_array = []
                    center_frequency_hit_array = []
                    if LoCenterFrequency == np.min(self.lo_frequency_dict[Key]):
                        for delta_frequency in self.effective_tuning_step_size:
                            max_additive_noise = 0
                            current_additive_noise = 0
                            current_tuning_range = delta_frequency * (
                                            self.lo_tuning_range // delta_frequency)
                            center_frequency_hit = False
                            # Need to add the + delta_frequency to the top end of the
                            # list to get actually specified range due to lack of
                            # inclusion on range end in python, grrrrr!! :(
                            for current_frequency in np.arange(
                                    LoCenterFrequency,
                                    LoCenterFrequency + current_tuning_range +
                                        delta_frequency,
                                                               delta_frequency):

                                current_additive_noise = np.interp(current_frequency,
                                                                   self._results_dictionary[
                                                                       Key][
                                                                       ReferenceFrequency][
                                                                       self.result_type_list[0]],
                                                                   self._results_dictionary[
                                                                       Key][
                                                                       ReferenceFrequency][
                                                                       self.result_type_list[2]])

                                if (current_additive_noise > max_additive_noise):
                                    max_additive_noise = current_additive_noise

                                if ~center_frequency_hit:
                                    if current_frequency == LoCenterFrequency:
                                        center_frequency_hit = True

                            max_additive_noise_array.append([delta_frequency, max_additive_noise])
                            current_tuning_range_array.extend([current_tuning_range])
                            center_frequency_hit_array.extend([center_frequency_hit])

                        max_additive_noise_array = np.array(max_additive_noise_array)
                        current_tuning_range_array = np.array(current_tuning_range_array)
                        center_frequency_hit_array = np.array(center_frequency_hit_array)

                        self._results_dictionary[
                                Key][
                                ReferenceFrequency][
                                LoCenterFrequency].update(
                                    {self.result_type_list[3]: max_additive_noise_array[:,0]})
                        self._results_dictionary[
                                Key][
                                ReferenceFrequency][
                                LoCenterFrequency].update(
                                    {self.result_type_list[4]: max_additive_noise_array[:,1]})
                        self._results_dictionary[
                                Key][
                                ReferenceFrequency][
                                LoCenterFrequency].update(
                                    {self.result_type_list[5]: current_tuning_range_array})
                        self._results_dictionary[
                                Key][
                                ReferenceFrequency][
                                LoCenterFrequency].update(
                                    {self.result_type_list[6]: center_frequency_hit_array})

                    elif LoCenterFrequency == np.max(self.lo_frequency_dict[Key]):
                        for delta_frequency in self.effective_tuning_step_size:
                            max_additive_noise = 0
                            current_additive_noise = 0
                            current_tuning_range = delta_frequency * (
                                            self.lo_tuning_range // delta_frequency)
                            center_frequency_hit = False
                            # Need to add the + delta_frequency to the top end of the
                            # list to get actually specified range due to lack of
                            # inclusion on range end in python, grrrrr!! :(
                            for current_frequency in np.arange(
                                    LoCenterFrequency - current_tuning_range,
                                    LoCenterFrequency + delta_frequency,
                                                               delta_frequency):

                                current_additive_noise = np.interp(current_frequency,
                                                                   self._results_dictionary[
                                                                       Key][
                                                                       ReferenceFrequency][
                                                                       self.result_type_list[0]],
                                                                   self._results_dictionary[
                                                                       Key][
                                                                       ReferenceFrequency][
                                                                       self.result_type_list[2]])

                                if (current_additive_noise > max_additive_noise):
                                    max_additive_noise = current_additive_noise

                                if ~center_frequency_hit:
                                    if current_frequency == LoCenterFrequency:
                                        center_frequency_hit = True

                            max_additive_noise_array.append([delta_frequency, max_additive_noise])
                            current_tuning_range_array.extend([current_tuning_range])
                            center_frequency_hit_array.extend([center_frequency_hit])

                        max_additive_noise_array = np.array(max_additive_noise_array)
                        current_tuning_range_array = np.array(current_tuning_range_array)
                        center_frequency_hit_array = np.array(center_frequency_hit_array)

                        self._results_dictionary[
                                Key][
                                ReferenceFrequency][
                                LoCenterFrequency].update(
                                    {self.result_type_list[3]: max_additive_noise_array[:,0]})
                        self._results_dictionary[
                                Key][
                                ReferenceFrequency][
                                LoCenterFrequency].update(
                                    {self.result_type_list[4]: max_additive_noise_array[:,1]})
                        self._results_dictionary[
                                Key][
                                ReferenceFrequency][
                                LoCenterFrequency].update(
                                    {self.result_type_list[5]: current_tuning_range_array})
                        self._results_dictionary[
                                Key][
                                ReferenceFrequency][
                                LoCenterFrequency].update(
                                    {self.result_type_list[6]: center_frequency_hit_array})

                    else:
                        for delta_frequency in self.effective_tuning_step_size:
                            max_additive_noise = 0
                            current_additive_noise = 0
                            current_tuning_range = delta_frequency * (
                                            self.lo_tuning_range // delta_frequency)
                            center_frequency_hit = False
                            # Need to add the + delta_frequency to the top end of the
                            # list to get actually specified range due to lack of
                            # inclusion on range end in python, grrrrr!! :(
                            for current_frequency in np.arange(
                                    LoCenterFrequency - current_tuning_range,
                                    LoCenterFrequency + current_tuning_range +
                                        delta_frequency,
                                                               delta_frequency):

                                current_additive_noise = np.interp(current_frequency,
                                                                   self._results_dictionary[
                                                                       Key][
                                                                       ReferenceFrequency][
                                                                       self.result_type_list[0]],
                                                                   self._results_dictionary[
                                                                       Key][
                                                                       ReferenceFrequency][
                                                                       self.result_type_list[2]])

                                if (current_additive_noise > max_additive_noise):
                                    max_additive_noise = current_additive_noise

                                if ~center_frequency_hit:
                                    if current_frequency == LoCenterFrequency:
                                        center_frequency_hit = True

                            max_additive_noise_array.append([delta_frequency, max_additive_noise])
                            current_tuning_range_array.extend([current_tuning_range])
                            center_frequency_hit_array.extend([center_frequency_hit])

                        max_additive_noise_array = np.array(max_additive_noise_array)
                        current_tuning_range_array = np.array(current_tuning_range_array)
                        center_frequency_hit_array = np.array(center_frequency_hit_array)

                        self._results_dictionary[
                                Key][
                                ReferenceFrequency][
                                LoCenterFrequency].update(
                                    {self.result_type_list[3]: max_additive_noise_array[:,0]})
                        self._results_dictionary[
                                Key][
                                ReferenceFrequency][
                                LoCenterFrequency].update(
                                    {self.result_type_list[4]: max_additive_noise_array[:,1]})
                        self._results_dictionary[
                                Key][
                                ReferenceFrequency][
                                LoCenterFrequency].update(
                                    {self.result_type_list[5]: current_tuning_range_array})
                        self._results_dictionary[
                                Key][
                                ReferenceFrequency][
                                LoCenterFrequency].update(
                                    {self.result_type_list[6]: center_frequency_hit_array})

    def worst_case_analysis(self):
        for Key in self.set_dict:
            reference_frequencies = self.set_dict[Key]
            for ReferenceFrequency in reference_frequencies:
                worst_case_maximum_array = []
                for Index in range(len(self.effective_tuning_step_size)):
                    worst_case_maximum = 0
                    current_worst_case_maximum = 0
                    for LoCenterFrequency in self.lo_frequency_dict[Key]:
                        current_worst_case_maximum = self._results_dictionary[
                                                        Key][
                                                        ReferenceFrequency][
                                                        LoCenterFrequency][
                                                        self.result_type_list[4]][Index]
                        if current_worst_case_maximum > worst_case_maximum:
                            worst_case_maximum = current_worst_case_maximum

                    worst_case_maximum_array.extend([worst_case_maximum])

                worst_case_maximum_array = np.array(worst_case_maximum_array)
                self._results_dictionary[
                            Key][
                            ReferenceFrequency].update(
                                {self.result_type_list[3]: self.effective_tuning_step_size})
                self._results_dictionary[
                            Key][
                            ReferenceFrequency].update(
                                {self.result_type_list[7]: worst_case_maximum_array})

    def write_results_to_excel(self):
        dataframe_dict = {}
        for Key in self.set_dict:
            reference_frequencies = self.set_dict[Key]
            for ReferenceFrequency in reference_frequencies:
                series_dict = {}
                series_dict.update({self.result_type_list[3]:
                    pd.Series(self.results_dictionary[
                                Key][
                                ReferenceFrequency][
                                self.result_type_list[3]],
                              name=self.result_type_list[3])})
                series_dict.update({self.result_type_list[7]:
                    pd.Series(self.results_dictionary[
                                Key][
                                ReferenceFrequency][
                                self.result_type_list[7]],
                              name=self.result_type_list[7])})
                for LoCenterFrequency in self.lo_frequency_dict[Key]:
                    series_dict.update({'Additive Noise '
                                        'Results_for_{0}MHz'.format(LoCenterFrequency):
                        pd.Series(self.results_dictionary[
                                    Key][
                                    ReferenceFrequency][
                                    LoCenterFrequency][
                                    self.result_type_list[4]],
                                  name='Additive Noise '
                                        'Results_for_{0}MHz'.format(LoCenterFrequency))})
                dataframe_dict.update({'AdditiveNoise{0}With'
                                           '{1}MHzRef'.format(Key,
                                                               ReferenceFrequency):
                                       pd.DataFrame.from_dict(series_dict).set_index(
                                           [self.result_type_list[3]])
                                       })
                order = dataframe_dict['AdditiveNoise{0}With'
                                       '{1}MHzRef'.format(Key,
                                                          ReferenceFrequency)
                                      ].columns.tolist()
                order = order[-1:] + order[:-1]
                dataframe_dict['AdditiveNoise{0}With'
                               '{1}MHzRef'.format(Key,
                                                  ReferenceFrequency)
                              ] = dataframe_dict['AdditiveNoise{0}With'
                                                 '{1}MHzRef'.format(Key,
                                                                    ReferenceFrequency)
                                                ].ix[:, order]

        dataframe_dict_2 = {}
        for Key in self.set_dict:
            reference_frequencies = self.set_dict[Key]
            for ReferenceFrequency in reference_frequencies:
                series_dict = {}
                series_dict.update({self.result_type_list[0]:
                    pd.Series(self.results_dictionary[
                                Key][
                                ReferenceFrequency][
                                self.result_type_list[0]],
                              name=self.result_type_list[0])})
                series_dict.update({self.result_type_list[1]:
                    pd.Series(self.results_dictionary[
                                Key][
                                ReferenceFrequency][
                                self.result_type_list[1]],
                              name=self.result_type_list[1])})
                dataframe_dict_2.update({'Spurious{0}With'
                                           '{1}MHzRef'.format(Key,
                                                               ReferenceFrequency):
                                       pd.DataFrame.from_dict(series_dict).set_index(
                                           [self.result_type_list[0]])
                                       })
        for Key in dataframe_dict:
            writer = pd.ExcelWriter(os.path.join(self.file_path,
                                       self.results_directory_name,
                                       '{0}.xlsx'.format(Key)),
                                    engine='xlsxwriter')
            dataframe_dict[Key].to_excel(writer, sheet_name=Key)
            writer.save()
        for Key in dataframe_dict_2:
            writer = pd.ExcelWriter(os.path.join(self.file_path,
                                       self.results_directory_name,
                                       '{0}.xlsx'.format(Key)),
                                    engine='xlsxwriter')
            dataframe_dict_2[Key].to_excel(writer, sheet_name=Key)
            writer.save()

    def create_results_folder(self):
        dir_count = 0
        while(self.results_directory_name == None):
            try:
                os.listdir(os.path.join(self.file_path,'Results_{0}'.format(dir_count)))
            except FileNotFoundError as e:
                os.mkdir(os.path.join(self.file_path,'Results_{0}'.format(dir_count)))
                self._results_directory_name = 'Results_{0}'.format(dir_count)
            except PermissionError as e:
                print('L1 PermissionError: ',e)
                dir_count = dir_count + 1
            else:
                try:
                    os.rmdir(os.path.join(self.file_path,'Results_{0}'.format(dir_count)))
                except OSError as e:
                    print('L2 OSError: ',e)
                    dir_count = dir_count + 1
                except PermissionError as e:
                    print('L2 PermissionError: ',e)
                    dir_count = dir_count + 1
                else:
                   try:
                       os.mkdir(os.path.join(self.file_path,'Results_{0}'.format(dir_count)))
                   except PermissionError as e:
                       print('L3 PermissionError: ',e)
                       dir_count = dir_count + 1
                   else:
                       self._results_directory_name = 'Results_{0}'.format(dir_count)

    def spurious_plots_vs_synthesizer_output(self, Action, **kwargs):
        """

        Parameters
        ----------

            Action : String
                     display : displays results on screen
                     write : writes results to files in resutls directory

            Type : String
                   png : writes to png, only useful if Action='write'
                   pdf : writes to pdf, only useful if Action='write'

        Returns
        -------

        None

        """
        plt.close("all")

        if Action.lower() == 'display':
            plot_size = (7, 5)
        elif Action.lower() == 'write':
            plot_size = (18, 10)

        for Key in self.set_dict:
            reference_frequencies = self.set_dict[Key]
            for ReferenceFrequency in reference_frequencies:
                fig = plt.figure('{0} Synthesizer {1} results for '
                                 '{2}MHz Reference Frequency'.format(
                                         Key,
                                         self.result_type_list[1],
                                         ReferenceFrequency),
                                figsize=plot_size)
                plt.title('{0} Synthesizer IBS results for '
                           '{2}MHz Reference Frequency'.format(
                        Key,
                        self.result_type_list[1],
                        ReferenceFrequency))

                plt.plot(self.results_dictionary[Key][ReferenceFrequency][self.result_type_list[0]],
                         self.results_dictionary[Key][ReferenceFrequency][self.result_type_list[1]],
                         label='Dominant IBS Spur Value')
                plt.legend()

                plt.legend(bbox_to_anchor=(0.99, 0.99), loc='upper right', borderaxespad=0.)

                plt.grid(color='k', linestyle='--', linewidth=0.5)
                plt.grid(which='major', alpha=0.9)

                resolution = 20
                size = self.results_dictionary[Key][ReferenceFrequency][self.result_type_list[0]].size
                min_x = self.results_dictionary[Key][ReferenceFrequency][self.result_type_list[0]][0]
                max_x = self.results_dictionary[Key][ReferenceFrequency][self.result_type_list[0]][-1]
                plt.xticks(np.arange(min_x, max_x, ((max_x - min_x) // resolution)))

                ax = fig.add_subplot(1, 1, 1)

                ax.set_xticks(self.results_dictionary[
                                Key][
                                ReferenceFrequency][
                                self.result_type_list[0]][0::(size // (resolution * 2))],
                              minor=True)

                plt.grid(which='minor', color='k', linestyle='--', linewidth=0.5)
                plt.grid(which='minor', alpha=0.3)

                plt.xlabel('Frequency (MHz)')
                plt.ylabel('Dominant IBS Spur Value (dBc)')

                if Action.lower() == 'write':
                    if kwargs['Type'].lower() == 'png':
                        plt.savefig(os.path.join(self.file_path,
                                               self.results_directory_name,
                                               'Dominant_IBS_Spur_Value_'
                                               '{0}_Synthesizer_{1}MHz_Ref_vs_tuneF'.format(
                                                       Key,
                                                       ReferenceFrequency)),
                                    bbox_inches='tight')
                    elif kwargs['Type'].lower() == 'pdf':
                        plt.savefig(os.path.join(self.file_path,
                                               self.results_directory_name,
                                               'Dominant_IBS_Spur_Value_'
                                               '{0}_Synthesizer_{1}MHz_Ref_vs_tuneF'.format(
                                                       Key,
                                                       ReferenceFrequency)),
                                    bbox_inches='tight',
                                    format='pdf')
                elif Action.lower() == 'display':
                    plt.show()

    def additive_noise_plots_vs_synthesizer_output(self, Action, **kwargs):
        """

        Parameters
        ----------

            Action : String
                     display : displays results on screen
                     write : writes results to files in resutls directory

            Type : String
                   png : writes to png, only useful if Action='write'
                   pdf : writes to pdf, only useful if Action='write'

        Returns
        -------

        None

        """
        plt.close("all")

        if Action.lower() == 'display':
            plot_size = (7, 5)
        elif Action.lower() == 'write':
            plot_size = (18, 10)

        for Key in self.set_dict:
            reference_frequencies = self.set_dict[Key]
            for ReferenceFrequency in reference_frequencies:
                fig = plt.figure('{0} Synthesizer {1} results for '
                                 '{2}MHz Reference Frequency'.format(
                                         Key,
                                         self.result_type_list[2],
                                         ReferenceFrequency),
                                 figsize=plot_size)
                plt.title('{0} Synthesizer Additive results for '
                           '{2}MHz Reference Frequency'.format(
                        Key,
                        self.result_type_list[1],
                        ReferenceFrequency))

                plt.plot(self.results_dictionary[Key][ReferenceFrequency][self.result_type_list[0]],
                         self.results_dictionary[Key][ReferenceFrequency][self.result_type_list[2]],
                         label='Cumulative additive Noise Due To IBSs')
                plt.legend()

                plt.legend(bbox_to_anchor=(0.99, 0.99), loc='upper right', borderaxespad=0.)

                plt.grid(color='k', linestyle='--', linewidth=0.5)
                plt.grid(which='major', alpha=0.9)

                resolution = 20
                size = self.results_dictionary[Key][ReferenceFrequency][self.result_type_list[0]].size
                min_x = self.results_dictionary[Key][ReferenceFrequency][self.result_type_list[0]][0]
                max_x = self.results_dictionary[Key][ReferenceFrequency][self.result_type_list[0]][-1]
                plt.xticks(np.arange(min_x, max_x, ((max_x - min_x) // resolution)))

                ax = fig.add_subplot(1, 1, 1)

                ax.set_xticks(self.results_dictionary[
                                Key][
                                ReferenceFrequency][
                                self.result_type_list[0]][0::(size // (resolution * 2))],
                              minor=True)

                plt.grid(which='minor', color='k', linestyle='--', linewidth=0.5)
                plt.grid(which='minor', alpha=0.3)

                plt.xlabel('Frequency (MHz)')
                plt.ylabel('Cumulative Additive Noise (degrees RMS)')

                if Action.lower() == 'write':
                    if kwargs['Type'].lower() == 'png':
                        plt.savefig(os.path.join(self.file_path,
                                               self.results_directory_name,
                                               'Cumulative_Additive_IBS_Noise_'
                                               '{0}_Synthesizer_{1}MHz_Ref_vs_tuneF'.format(
                                                       Key,
                                                       ReferenceFrequency)),
                                    bbox_inches='tight')
                    elif kwargs['Type'].lower() == 'pdf':
                        plt.savefig(os.path.join(self.file_path,
                                               self.results_directory_name,
                                               'Cumulative_Additive_IBS_Noise_'
                                               '{0}_Synthesizer_{1}MHz_Ref_vs_tuneF'.format(
                                                       Key,
                                                       ReferenceFrequency)),
                                    bbox_inches='tight',
                                    format='pdf')
                elif Action.lower() == 'display':
                    plt.show()

    def additive_noise_plots_vs_tuning_step_size(self, Action, **kwargs):
        """

        Parameters
        ----------

            Action : String
                     display : displays results on screen
                     write : writes results to files in resutls directory

            Type : String
                   png : writes to png, only useful if Action='write'
                   pdf : writes to pdf, only useful if Action='write'

        Returns
        -------

        None

        """
        plt.close("all")

        if Action.lower() == 'display':
            plot_size = (7, 5)
        elif Action.lower() == 'write':
            plot_size = (18, 10)

        for Key in self.set_dict:
            reference_frequencies = self.set_dict[Key]
            for ReferenceFrequency in reference_frequencies:
                fig = plt.figure('{0} Synthesizer {1} results for '
                                 '{2}MHz Reference Frequency'.format(
                                Key,
                                self.result_type_list[1],
                                ReferenceFrequency),
                                figsize=plot_size)
                plt.title('Cumulative Additive Noise Due To Integer Boundary Spurs\n'
                          '{0} Synthesizer {1}MHz Reference Frequency Results'.format(
                                Key,
                                ReferenceFrequency))

                for LoCenterFrequency in self.lo_frequency_dict[Key]:
                    plt.plot(self.results_dictionary[Key][ReferenceFrequency][LoCenterFrequency][self.result_type_list[3]],
                             self.results_dictionary[Key][ReferenceFrequency][LoCenterFrequency][self.result_type_list[4]],
                             '-o',
                             label=('{0}MHz Synthesizer '
                                    'Center Frequency'.format(LoCenterFrequency)))
                    plt.legend()
                plt.plot(self.results_dictionary[Key][ReferenceFrequency][LoCenterFrequency][self.result_type_list[3]],
                         self.cumulative_additive_noise_limit *
                         np.ones(self.results_dictionary[Key][ReferenceFrequency][LoCenterFrequency][self.result_type_list[3]].size),
                         label='Cumulative Additive Noise Limit')
                plt.legend()

                plt.legend(bbox_to_anchor=(0.99, 0.99), loc='upper right', borderaxespad=0.)

                plt.grid(color='k', linestyle='--', linewidth=0.5)
                plt.grid(which='major', alpha=0.9)

                resolution = 20
                min_x = self.results_dictionary[Key][ReferenceFrequency][self.result_type_list[3]][0]
                max_x = self.results_dictionary[Key][ReferenceFrequency][self.result_type_list[3]][-1]
                plt.xticks(np.arange(min_x, max_x, ((max_x - min_x) // resolution)))

                ax = fig.add_subplot(1, 1, 1)
                ax.set_xticks(self.results_dictionary[Key][ReferenceFrequency][self.result_type_list[3]],
                              minor=True)

                plt.grid(which='minor', color='k', linestyle='--', linewidth=0.5)
                plt.grid(which='minor', alpha=0.3)

                plt.xlabel('Frequency (MHz)')
                plt.ylabel('Cumulative Additive Noise (degrees RMS)')

                if Action.lower() == 'write':
                    if kwargs['Type'].lower() == 'png':
                        plt.savefig(os.path.join(self.file_path,
                                               self.results_directory_name,
                                               'Cumulative_Additive_IBS_Noise_'
                                               '{0}_Synthesizer_{1}MHz_Ref_vs_tune_step'.format(
                                                       Key,
                                                       ReferenceFrequency)),
                                    bbox_inches='tight')
                    elif kwargs['Type'].lower() == 'pdf':
                        plt.savefig(os.path.join(self.file_path,
                                               self.results_directory_name,
                                               'Cumulative_Additive_IBS_Noise_'
                                               '{0}_Synthesizer_{1}MHz_Ref_vs_tune_step'.format(
                                                       Key,
                                                       ReferenceFrequency)),
                                    bbox_inches='tight',
                                    format='pdf')
                elif Action.lower() == 'display':
                    plt.show()

    def worst_case_additive_noise_plots_vs_tuning_step_size(self, Action, **kwargs):
        """

        Parameters
        ----------

            Action : String
                     display : displays results on screen
                     write : writes results to files in resutls directory

            Type : String
                   png : writes to png, only useful if Action='write'
                   pdf : writes to pdf, only useful if Action='write'

        Returns
        -------

        None

        """
        plt.close("all")

        if Action.lower() == 'display':
            plot_size = (7, 5)
        elif Action.lower() == 'write':
            plot_size = (18, 10)

        for Key in self.set_dict:
            reference_frequencies = self.set_dict[Key]
            for ReferenceFrequency in reference_frequencies:
                fig = plt.figure('{0} Synthesizer Worst Case results for '
                                 '{1}MHz Reference Frequency'.format(
                                Key,
                                ReferenceFrequency),
                                figsize=plot_size)
                plt.title('Cumulative Additive Noise Due To Integer Boundary Spurs\n'
                          '{0} Synthesizer {1}MHz Reference Frequency Results'.format(
                                Key,
                                ReferenceFrequency))

                plt.plot(self.results_dictionary[Key][ReferenceFrequency][self.result_type_list[3]],
                         self.results_dictionary[Key][ReferenceFrequency][self.result_type_list[7]],
                         '-o',
                         label=('Limiting Synthesizer Case Only'))
                plt.legend()

                plt.plot(self.results_dictionary[Key][ReferenceFrequency][self.result_type_list[3]],
                         self.cumulative_additive_noise_limit *
                         np.ones(self.results_dictionary[Key][ReferenceFrequency][self.result_type_list[3]].size),
                         label='Cumulative Additive Noise Limit')
                plt.legend()

                plt.legend(bbox_to_anchor=(0.99, 0.99), loc='upper right', borderaxespad=0.)

                plt.grid(color='k', linestyle='--', linewidth=0.5)
                plt.grid(which='major', alpha=0.9)

                resolution = 20
                min_x = self.results_dictionary[Key][ReferenceFrequency][self.result_type_list[3]][0]
                max_x = self.results_dictionary[Key][ReferenceFrequency][self.result_type_list[3]][-1]
                plt.xticks(np.arange(min_x, max_x, ((max_x - min_x) // resolution)))

                ax = fig.add_subplot(1, 1, 1)
                ax.set_xticks(self.results_dictionary[Key][ReferenceFrequency][self.result_type_list[3]],
                              minor=True)

                plt.grid(which='minor', color='k', linestyle='--', linewidth=0.5)
                plt.grid(which='minor', alpha=0.3)

                plt.xlabel('Frequency (MHz)')
                plt.ylabel('Cumulative Additive Noise (degrees RMS)')

                if Action.lower() == 'write':
                    if kwargs['Type'].lower() == 'png':
                        plt.savefig(os.path.join(self.file_path,
                                               self.results_directory_name,
                                               'Cumulative_Worst_Case_Additive_IBS_Noise_'
                                               '{0}_Synthesizer_{1}MHz_Ref_vs_tune_step'.format(
                                                       Key,
                                                       ReferenceFrequency)),
                                    bbox_inches='tight')
                    elif kwargs['Type'].lower() == 'pdf':
                        plt.savefig(os.path.join(self.file_path,
                                               self.results_directory_name,
                                               'Cumulative_Worst_Case_Additive_IBS_Noise_'
                                               '{0}_Synthesizer_{1}MHz_Ref_vs_tune_step'.format(
                                                       Key,
                                                       ReferenceFrequency)),
                                    bbox_inches='tight',
                                    format='pdf')
                elif Action.lower() == 'display':
                    plt.show()

    def close_all_figs(self):
        plt.close("all")


class PhaseNoise(object):
    r"""
    This is a class that takes 3 pieces of information and makes an object
    that is much easier to work with for phase noise calculations.  The main
    purpose is to contain all the functions necessary for data manipulation
    to keep the main code clean.

    Parameters
    ----------

        Frequency Offset Phase Noise : List, Float
                     This is a list of list pairs that contains the
                     frequency offset and its corresponding phase noise value

        Specification Frequency : Float
                     This is the frequency at which the Frequency Offset Phase
                     Noise List is specified

        System Impedance : List, Float
                     This is list of list pairs that contains the frequency
                     dependant impedance the that will be used for translation
                     to voltage noise and current noise when necessary at each
                     frequency offset.  If a singe value is passed in instead
                     then the single value will be applied at all frequency
                     offsets

    Returns
    -------

        object : PhaseNoise object
                 This object is what you can interact with to simplify
                 analysis and calculation

    See Also
    --------

    Nothing currently

    Example
    -------

    >>> phase_noise = [[0.1,-144], [1,-165], [10,-167],
    >>>                [100,-168], [1000,-168], [10000,-169]]
    >>> frequency = 10e6
    >>> impedance = 50
    >>> instance = PhaseNoise(
    >>>                phase_noise,
    >>>                frequency,
    >>>                impedance)
    <simpyle_systems.synthesizer.PhaseNoise at 0xab73a58>


    """

    def __init__(self, *args):
        self._storage_mode = 'pair'
        # Intake Processing
        if len(args) == 3:
            self._phase_noise = args[0]
            self._specification_frequency = args[1]
            self._current_frequency = args[1]
            self._impedance = args[2]
        self._phase_noise_split = []
        self._phase_noise_pair = []
        self.update_sp()

    @property
    def storage_mode(self):
        return self._storage_mode

    @storage_mode.setter
    def storage_mode(Value):
        self._storage_mode = Value

    @property
    def phase_noise(self):
        return self._phase_noise

    @phase_noise.setter
    def phase_noise(Value):
        self._phase_noise = Value

    @property
    def specification_frequency(self):
        return self._specification_frequency

    @specification_frequency.setter
    def specification_frequency(Value):
        self._specification_frequency = Value

    @property
    def current_frequency(self):
        return self._current_frequency

    @current_frequency.setter
    def current_frequency(Value):
        self._current_frequency = Value

    @property
    def impedance(self):
        return self._impedance

    @impedance.setter
    def impedance(Value):
        self._impedance = Value

    @property
    def phase_noise_split(self):
        return self._phase_noise_split

    @phase_noise_split.setter
    def phase_noise_split(Value):
        self._phase_noise_split = Value

    @property
    def phase_noise_pair(self):
        return self._phase_noise_pair

    @phase_noise_pair.setter
    def phase_noise_pair(Value):
        self._phase_noise_pair = Value

    @staticmethod
    def logspace(Start, NumberOfDecades):
        logspace_vector = [Start*i*n
                           for i in np.power(10,np.array(range(0,NumberOfDecades)))
                           for n in range(1,10)]
        logspace_vector.extend([np.power(10,np.log10(Start)+NumberOfDecades)])
        return logspace_vector

    @staticmethod
    def interpolate(XValues, YValues, NewXValues, InterpolationType):
        if InterpolationType.upper() == 'LOG':
            NewYValues = [YValues[0]]
            NewXIndex = 1
            for XIndex in range(1, len(XValues)):
                if XIndex < (len(XValues)-1):
                    while NewXValues[NewXIndex] <= XValues[XIndex]:
                        dy_log = YValues[XIndex] - YValues[XIndex-1]
                        del_x_log = 10*np.log10(NewXValues[NewXIndex] /
                                                NewXValues[NewXIndex-1])
                        dx_log = 10*np.log10(XValues[XIndex] /
                                             XValues[XIndex-1])
                        NewYValues.extend([NewYValues[NewXIndex-1] +
                                           ((del_x_log * dy_log) / dx_log)])
                        NewXIndex += 1
                else:
                    while NewXValues[NewXIndex] < XValues[XIndex]:
                        dy_log = YValues[XIndex] - YValues[XIndex-1]
                        del_x_log = 10*np.log10(NewXValues[NewXIndex] /
                                                NewXValues[NewXIndex-1])
                        dx_log = 10*np.log10(XValues[XIndex] /
                                             XValues[XIndex-1])
                        NewYValues.extend([NewYValues[NewXIndex-1] +
                                           ((del_x_log * dy_log) / dx_log)])
                        NewXIndex += 1
            NewYValues.extend([YValues[-1]])
            return NewYValues
        else:
            pass
        pass

    def interpolate_self(self, NewXValues, InterpolationType):
        self._phase_noise = \
            self.pair(NewXValues,
                      self.interpolate(self.split(self.phase_noise)[0],
                                       self.split(self.phase_noise)[1],
                                       NewXValues,
                                       InterpolationType))
        self.update_sp()

    def interpolate_self_logspace(self):
        self.interpolate_self(
                self.logspace(self.phase_noise[0][0],
                              int(np.log10(self.phase_noise[-1][0] /
                                           self.phase_noise[0][0]))),
                              'log')
        self.update_sp()

    def phase_noise_fill(self, PhaseNoiseOffsetVector, FillValue):
        PhaseNoisePairVector = self.phase_noise
        if FillValue == []:
            if PhaseNoisePairVector[0][0] == PhaseNoiseOffsetVector[0]:
                FillValue = PhaseNoisePairVector[-1][1]
            elif PhaseNoisePairVector[-1][0] == PhaseNoiseOffsetVector[-1]:
                FillValue = PhaseNoisePairVector[0][1]
            else:
                pass
        defined_offsets = [PhaseNoisePairVector[index][0]
                           for index, v in enumerate(PhaseNoisePairVector)]
        for Offset in PhaseNoiseOffsetVector:
            if not(Offset in defined_offsets):
                PhaseNoisePairVector.extend([[Offset, FillValue]])
        PhaseNoisePairVector.sort()
        self._phase_noise = PhaseNoisePairVector
        self.update_sp()

    def phase_noise_strip(self, StripValue):
        PhaseNoisePairVector = self.phase_noise
        new_phase_noise_pair_vector = \
            [PhaseNoisePairVector[index]
            for index, v in enumerate(PhaseNoisePairVector)
            if PhaseNoisePairVector[index][1] > StripValue]
        self._phase_noise = new_phase_noise_pair_vector
        self.update_sp()

    def pair_self(self):
        if self.storage_mode == 'split':
            self._phase_noise = self.phase_noise_pair
            self._storage_mode = 'pair'
        else:
            print('error, already in pair storage format')

    def split_self(self):
        if self.storage_mode == 'pair':
            self._phase_noise = self.phase_noise_split
            self._storage_mode = 'split'
        else:
            print('error, already in split storage format')

    def update_sp(self):
        if self.storage_mode == 'pair':
            self._phase_noise_split = self.split(self.phase_noise)
            self._phase_noise_pair = self.phase_noise
        else:
            self._phase_noise_split = self.phase_noise
            self._phase_noise_pair = self.pair(self.phase_noise[0],
                                               self.phase_noise[1])

    def change_frequency(self, NewFrequency):
        self._phase_noise = self.scale_phase_noise(self.phase_noise,
                                                   self.current_frequency,
                                                   NewFrequency)
        self._current_frequency = NewFrequency
        self.update_sp()

    @staticmethod
    def pair(x, y):
        output = []
        for Index in range(len(x)):
            output.append([x[Index], y[Index]])
        return output

    @staticmethod
    def split(x):
        output = []
        for Index in range(len(x[0])):
            output.append([y[Index] for y in x])
        return output

    @classmethod
    def combine(self, x, y):
        output = []
        for Index, Value in enumerate(x):
            output.append([x[Index][1] + y[Index][1]])
        return self.pair(self.split(x)[0], output)

    @staticmethod
    def scale_phase_noise(PhaseNoise, CurrentFrequency, OutputFrequency):
        output = []
        for Index in range(len(PhaseNoise)):
            output.append([PhaseNoise[Index][0],
                           PhaseNoise[Index][1] + 20*np.log10(OutputFrequency /
                                                              CurrentFrequency)])
        return output
